\documentclass[11pt]{article}

\usepackage[portuguese]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{listings}
\usepackage{hyphenat}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{caption}
\usepackage[utf8]{inputenc}
\usepackage{array}

\title{\textbf{Escolha e Implementação de um Framework Front-end para o MVP Cow8}}
\author{
    Renan da Silva Oliveira Andrade (\texttt{renan.silva3@pucpr.edu.br})\\
    Ricardo Lucas Kucek (\texttt{ricardo.kucek@pucpr.edu.br})\\
    Pedro Senes Velloso Ribeiro (\texttt{pedro.senes@pucpr.edu.br})\\
    Riscala Miguel Fadel Neto (\texttt{riscala.neto@pucpr.edu.br})\\
    Victor Valerio Fadel (\texttt{victor.fadel@pucpr.edu.br})
}

\begin{document}
\maketitle

\section{Introdução}

Contextualização do projeto, objetivos do front-end e importância da escolha de um framework.

\section{Principais Características de Frameworks Front-end}

Discussão sobre modelos, bibliotecas, classes e métodos em frameworks como Bootstrap, Tailwind CSS, React, Vue.js, etc.

\section{Ferramentas e Tecnologias em Frameworks Front-end}

Comparação entre HTML, CSS e JavaScript puros e o uso de frameworks, destacando vantagens e desvantagens.

\section{Avaliação das Necessidades do Projeto}

Análise dos requisitos do projeto (responsividade, usabilidade, desempenho) e como um framework pode atendê-los.

\section{Escolha do Framework Front-end}

Dentre as alternativas presentes no mercado, o MVP Cow8 utiliza o framework front-end \textbf{Tailwind CSS}, pois melhor se adequou aos requisitos de implementação do projeto.

\subsection{Análise Comparativa entre Frameworks Considerados}

Os frameworks considerados para o desenvolvimento foram: \textbf{React.js, Bootstrap e Tailwind CSS}. Foram realizadas análises comparativas primordialmente imparciais sobre as vantagens e desvantagens de se usar cada framework, baseadas em 4 pontos críticos: \textbf{Facilidade de uso, Customização, Performance e Integração com o Flask.}

\begin{table}[H]
\centering
\caption{Comparação de Facilidade de Uso}
\begin{tabular}{lccc}
\toprule
\textbf{Framework} & \textbf{Documentação} & \textbf{Comunidade} & \textbf{Curva de Aprendizado} \\
\midrule
React & Excelente & Muito grande & Alta \\
Bootstrap & Muito boa & Enorme & Baixa a média \\
Tailwind CSS & Boa & Crescente & Média \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Comparação de Capacidade de Customização}
\begin{tabular}{lccc}
\toprule
\textbf{Framework} & \textbf{Flexibilidade} & \textbf{Temas Prontos} & \textbf{Override de Estilos} \\
\midrule
React & Alta & Dependente & Requer CSS adicional \\
Bootstrap & Limitada & Muitos & Possível com Sass \\
Tailwind CSS & Máxima & Poucos & Fácil \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Comparação de Performance}
\begin{tabular}{lccc}
\toprule
\textbf{Framework} & \textbf{Tam. Bundle} & \textbf{Renderização} & \textbf{Otimização} \\
\midrule
React & Grande & Client-side & Code-splitting necessário \\
Bootstrap & Moderado & Server-side & PurgeCSS recomendado \\
Tailwind CSS & Leve & Server-side & Automática \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Comparação de Integração com Flask}
\begin{tabular}{lccc}
\toprule
\textbf{Framework} & \textbf{Configuração} & \textbf{Templates (Jinja2)} & \textbf{Complexidade} \\
\midrule
React & Complexa & Incompatível direta & Alta \\
Bootstrap & Simples & Perfeita & Baixa \\
Tailwind CSS & Moderada & Funciona & Média \\
\bottomrule
\end{tabular}
\end{table}

Através destas análises, conclui-se que cada framework proporciona resultados únicos. Para cada framework, observa-se que é benéfico nos seguintes casos:

\begin{itemize}
\item \textbf{Bootstrap}: Melhor para projetos simples e rápidos com Flask
\item \textbf{Tailwind CSS}: Ideal para designs customizados sem sacrificar performance
\item \textbf{React}: Recomendado apenas para aplicações complexas com frontend separado
\end{itemize}

\subsection{Motivos da Escolha do Framework Tailwind CSS}

O front-end do MVP Cow8 utiliza-se do framework Tailwind CSS. Existem diversos motivos pelos quais o projeto melhor se adapta ao uso de Tailwind, baseados nas análises apresentadas no capítulo anterior:

\begin{itemize}
\item \textbf{Customização}: O objetivo é criar uma interface altamente customizável e reutilizável, e o Tailwind atende à este requisito.
\item \textbf{Integração com Templates Jinja2}: A combinação do uso dos templates com as classes inline do Tailwind permitem que os estilos das páginas sejam facilmente modificadas onde houver necessidade, sem preocupação com o uso de arquivos de estilos externos que necessitam ser importados de arquivos estáticos.
\item \textbf{Ausência de \textit{Bloatware}}: O Tailwind possui um bundle leve, o que diminui o tempo de renderização e de carregamento das páginas, proporcionando uma experiência de usuário mais avantajada e uma economia de processamento que pode ser direcionada à outras tarefas mais críticas e relevantes, como o processamento de requests de banco de dados e processamento de mensagens WebSocket do broker MQTT.
\item \textbf{Fácil configuração para produção e desenvolvimento via CDN}: A utilização do Tailwind em desenvolvimento é simples, necessitando apenas de um \texttt{<script>} CDN no corpo dos arquivos HTML. Para produção, a configuração também é simples.
\end{itemize}

\section{Implementação do Design Front-end}

\subsection{Estrutura de Diretórios}

O projeto segue uma estrutura de diretórios simples, contando com os Blueprints Flask, módulos de banco de dados e MQTT próprios e \textit{Shell Scripts} utilizados para automatizar o procedimento de inicialização limpa (pois o projeto está sendo desenvolvido em um container Docker, o qual pode ocasionar corrupções em certas situações).

O arquivo \texttt{requirements.txt} lista todas as dependências de bibliotecas Python do projeto, sendo facilmente instaladas recursivamente no desenvolvimento com o uso de um \textit{Virtual Environment} (venv).

Além disso, os diretórios \texttt{static/} e \texttt{templates/} são os diretórios que contêm os arquivos estáticos e templates HTML, respectivamente.

\begin{verbatim}
    .
    |- api.py
    |- auth.py
    |- clean.sh
    |- database/
    |- __init__.py
    |- main.py
    |- mqtt.py
    |- requirements.txt
    |- static/
    |- templates/

\end{verbatim}

\subsection{Template base e configuração do Tailwind}

Para tornar o Tailwind CSS disponível para o projeto, foi optado por utilizar a versão CDN (\textit{Content Delivery Network}), que pode ser facilmente incluída via tag HTML \texttt{<script>} no final da tag \texttt{<body>} ou na tag \texttt{<head>}. Esta versão não é indicada para produção, mas é uma ótima ferramenta para agilizar o processo de desenvolvimento da aplicação web sem se preocupar com as configurações dos módulos NPM (\textit{Node Package Modules}), os quais, todavia, são os indicados para um ambiente de produção.

A melhor solução neste caso (quando possível) foi incluir o CDN no template \texttt{base.html}, o qual serve de base para todas as páginas do projeto (exceto a de login) e, portanto, já disponibiliza o Tailwind para todas as páginas automaticamente.

\subsection{Hospedagem do Flask com Docker}

A fim de isolar o ambiente, tornando-o facilmente compartilhável e removendo a necessidade de configuração manual do projeto, foi utilizado o \textbf{Docker Compose}.

Em um arquivo \texttt{docker-compose.yaml}, foram definidas configurações de hospedagem, servidores DNS e verificação de integridade. Isto torna o ambiente isolável e menos suscetível a erros causados por falhas de configuração do ambiente de desenvolvimento.

Outro critério de optar por utilizar Docker foi a integração com um banco de dados \textbf{MySQL}, que também foi conteinerizado e configurado para rodar scripts SQL na inicialização para, por exemplo, inserir dados fictícios (\textit{dummy data}) a fim de realizar testes de usabilidade e funcionalidade e implementar as features de acordo. Com ambos os ambientes no mesmo container, a execução das dependências de cada um se torna extremamente trivial.

\subsection{Árvore de Páginas}

O projeto apresenta uma quantidade reduzida de páginas que objetivam fornecer a melhor experiência de usuário e fornecer todas as funcionalidades mais importantes no quesito de gerenciamento de acesso e de módulos de balança, bem como ferramentas de análise de dados com base em cálculos estatísticos dos dados das pesagens e ferramentas de controle remoto dos módulos. O projeto pode ser facilmente estendido e novas features implementadas, sem quebrar a compatibilidade com as atualmente disponíveis.

\begin{verbatim}
    /
    |- /login
    |- /scales
    |- | - /list
    |- | - /register
    |- /users
    |- | - /list
    |- | - /register

\end{verbatim}

\begin{itemize}
    \item \textbf{Endpoint \texttt{/}}: É o endpoint de dashbard do projeto, onde resumos mensais, análise de tendências, análises periódicas, análise com base em raças e uso dos módulos a partir dos dados em banco são apresentados, contando com gráficos visualmente agradáveis e legíveis gerados automaticamente com a biblioteca \textit{Chart.js}.
    \item \textbf{Endpoint \texttt{/login}}: É o endpoint de login no sistema via usuário ou email e a respectiva senha. O projeto conta com sessões, portanto, todas as outras páginas (exceto esta) somente são acessíveis se o usuário estiver logado.
    \item \textbf{Endpoint \texttt{/scales}}: Reservado.
    \item \textbf{Endpoint \texttt{/scales/list}}: É o endpoint de listagem de módulos de pesagem cadastrados no sistema. Através deste endpoint, quaisquer usuários podem ter acesso aos dados dos módulos, bem como verificar seus status em tempo real, além de métricas como a última data de tara e possíveis erros, por exemplo. \textit{O acesso a esta página é parcial, contando com algumas funcionalidades restritas as quais apenas o administrador está autorizado a utilizar.}
     \item \textbf{Endpoint \texttt{/scales/register}}: É o endpoint de cadastro de novos módulos de pesagem no sistema. \textit{Apenas o adminstrador tem acesso a esta página.}
     \item \textbf{Endpoint \texttt{/users}}: Reservado.
     \item \textbf{Endpoint \texttt{/users/list}}: É o endpoint de listagem de usuários cadastrados no sistema, contando com funcionalidades de banimento, deleção, verificação e alteração de dados de usuários. \textit{Apenas o administrador tem acesso a esta página.}
     \item \textbf{Endpoint \texttt{/users/register}}: É o endpoint de cadastro de novos usuários no sistema. \textit{Apenas o administrador tem acesso a esta página.}
\end{itemize}

\textbf{* É importante salientar que, com base nas permissões de cada usuário, o design de cada uma das páginas pode variar sucintamente.}

\section{Demonstração do Design}

Imagens ou links para demonstração do front-end desenvolvido.

\section{Conclusão}

Reflexão sobre as vantagens (produtividade, consistência visual) e desafios (curva de aprendizado, tamanho do bundle) do framework escolhido.

% \bibliographystyle{apalike}
% \bibliography{sample}

\end{document}
